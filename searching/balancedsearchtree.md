# 平衡查找树之2-3查找树

---

# 定义

二叉查找树在最快的情况下，性能还是很糟糕。

我们希望能够保持二叉查找树的平衡性。在一棵还有N个结点的树中，我们希望树的高度为logN，这样就能够保证所有的查找都能在logN次比较内结束。

2-3查找树允许树中的一个结点保存多个键。我们将一棵标准的二叉查找树中的结点称为2-结点（含有一个键和两条链接），现在引入3-结点，它含有两个键和三条链接。2-结点和3-结点中的每条链接都对应着其中保存的键所分割产生的一个区间。

一棵2-3查找树或为一棵空树，或由以下结点组成：

* 2-结点，含有一个键和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。
* 3-结点，含有两个键和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树种的键都位于该结点的两个键质检，右链接指向的2-3树种的键都大于该结点。

![](/assets/searching/balancedSearchTree_define1.png)

## 查找

要判断一个键是否在树种，我们先将它和根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向对应区间的链接，并在其指向的子树中递归地继续查找。如果这个链接是个空链接，查找未命中。

![](/assets/searching/balancedSearchTree_trace1.png)

## 向2-结点中插入新键

进行一次未命中查找，如果未命中查找结束于一个2-结点，只要将要插入的键保存在其中即可。![](/assets/searching/balancedSearchTree_trace2.png)

## 向一棵只含有一个3-结点的树中插入新键

为了将新键插入，我们临时将新键存入该结点中，使之成为一个4-结点，然后转换为一棵由3个2-结点组成的2-3树。

![](/assets/searching/balancedSearchTree_trace3.png)

## 向一个父结点为2-结点的3-结点中插入新键

先构造一个临时的4-结点并将其分解，但此时我们不会为中键创造一个新结点，而是将其移动至原来的父结点中。

![](/assets/searching/balancedSearchTree_trace4.png)

## 向一个父结点为3-结点的3-结点中插入新键

构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个3-结点，因此再用它的中键构造一个新的临时4-结点，然后再次分解，直到遇到一个2-结点，或者达到3-结点的根。

![](/assets/searching/balancedSearchTree_trace5.png)![](/assets/searching/balancedSearchTree_trace6.png)

![](/assets/searching/balancedSearchTree_trace7.png)

![](/assets/searching/balancedSearchTree_trace8.png)

## 复杂度

在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过**logN**个。

![](/assets/searching/balancedSearchTree_trace9.png)

2-3树在最坏情况下仍有很好的性能。

但是用这种方法实现起来并不方便，因为需要处理的情况太多。实现这些不仅需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。

